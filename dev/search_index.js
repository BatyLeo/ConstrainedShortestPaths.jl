var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ConstrainedShortestPaths]","category":"page"},{"location":"examples/#Examples-of-applications","page":"Examples of applications","title":"Examples of applications","text":"","category":"section"},{"location":"examples/#Usual-shortest-path","page":"Examples of applications","title":"Usual shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples of applications","title":"Examples of applications","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B","category":"page"},{"location":"examples/#Usual-resource-constrained-shortest-path","page":"Examples of applications","title":"Usual resource constrained shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples of applications","title":"Examples of applications","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B + mathbbI_q^F + q^B leq W","category":"page"},{"location":"examples/#Stochastic-routing","page":"Examples of applications","title":"Stochastic routing","text":"","category":"section"},{"location":"examples/","page":"Examples of applications","title":"Examples of applications","text":"warning: Coming soon\n","category":"page"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/test/custom.jl\"","category":"page"},{"location":"custom/#Build-a-custom-wrapper","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"","category":"section"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"warning: Work in progress\n","category":"page"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"using ConstrainedShortestPaths\nusing Graphs, SparseArrays\nimport Base: <=, minimum","category":"page"},{"location":"custom/#Resources","page":"Build a custom wrapper","title":"Resources","text":"","category":"section"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"struct Resource\n    c::Float64\n    w::Float64\nend","category":"page"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"function <=(r1::Resource, r2::Resource)\n    return r1.c <= r2.c && r1.w <= r2.w\nend\n\nfunction minimum(R::Vector{Resource})\n    return Resource(minimum(r.c for r in R), minimum(r.w for r in R))\nend","category":"page"},{"location":"custom/#Expansion-functions","page":"Build a custom wrapper","title":"Expansion functions","text":"","category":"section"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"struct ExpansionFunction\n    c::Float64\n    w::Float64\nend\n\nfunction (f::ExpansionFunction)(q::Resource)\n    return Resource(f.c + q.c, f.w + q.w)\nend","category":"page"},{"location":"custom/#Cost-function","page":"Build a custom wrapper","title":"Cost function","text":"","category":"section"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"struct Cost\n    W::Float64\nend\n\nfunction (cost::Cost)(fr::Resource, br::Resource)\n    return fr.w + br.w <= cost.W ? fr.c + br.c : Inf\nend","category":"page"},{"location":"custom/#Test","page":"Build a custom wrapper","title":"Test","text":"","category":"section"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)\n\nW = 1.0\n\ncost_list = [[0.], [0.], [10.], [0.], [0]]\nw = [0. for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), k) in zip(edge_list, cost_list)\n    w[i, j, :] = k\nend\n\n# origin forward resource and backward forward resource set to 0\nresource = Resource(0., 0.)\n\n# forward and backward expansion functions are equal\nIf = [src(e) for e in edges(graph)]\nJf = [dst(e) for e in edges(graph)]\nf = [ExpansionFunction(d[i, j], w[i, j]) for (i, j) in zip(If, Jf)]\nF = sparse(If, Jf, f);\n\ninstance = RCSPInstance(graph, resource, resource, Cost(W), F, F)\np_star, c_star = generalized_constrained_shortest_path(instance)","category":"page"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"","category":"page"},{"location":"custom/","page":"Build a custom wrapper","title":"Build a custom wrapper","text":"This page was generated using Literate.jl.","category":"page"},{"location":"math/#Theoretical-framework","page":"Theoretical framework","title":"Theoretical framework","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"This page explains the mathematical framework used by ConstrainedShortestPath.jl, and its application to a few examples It's simplified version of the framework from Parmentier 2017, retricted to acyclic graphs.","category":"page"},{"location":"math/#Generalized-constrained-shortest-path","page":"Theoretical framework","title":"Generalized constrained shortest path","text":"","category":"section"},{"location":"math/#Problem-formulation","page":"Theoretical framework","title":"Problem formulation","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Let D = (V A) be an acyclic digraph. Let o d two vertices, and mathcalP_od the set of o-d path in D. We want to find a path in P^star inmathcalP_od minimizing a cost function Pmapsto c_P:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"boxedmin_PinmathcalP_odc_P","category":"page"},{"location":"math/#Setting","page":"Theoretical framework","title":"Setting","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We define the two following set of resources:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Set of forward resources Q^F, with a partial order leq^F\nSet of backward resources Q^B, with a partial order leq^B","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"A partially ordered set (Sleq) is a lattice if any pair s sin S, admits a greatest lower bound swedge s, i.e. forall b bleq swedge s, b leq s and bleq s.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"(Q^F leq^F) and (Q^B leq^B) are lattice.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"For every arc ain A, we define two functions:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Forward extension function : f^F_aQ^F to Q^F increasing\nBackward extension function : f^B_a  Q^B to Q^B increasing","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We also define:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"A cost function : cQ^Ftimes Q^B to mathbbRcup+infty increasing\nAn origin vertex o, with a corresponding ressource q^F_oin Q^F\nA destination vertex d, with a corresponding ressource q^B_din Q^B","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Finally need the following (equivalent) properties to hold:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"For all o-d path P = (o=v_0 a_1 v_1 dots a_k v_k=d), we have :\nboxedforall i iin k c(f^F_i circ f^F_i-1circdotscirc f^F_1(q^F_o) f^B_i+1 circ f^B_i+2circdotscirc f^B_k(q^B_d)) = c_PinmathbbRcup+infty\nFor all o-d path P and every decomposition of P as (R_1 R_2), we have c_P=c(q^F_R_1 q^B_R_2), with:\nFor all o-v path R_1 = (o=v_0 a_1 v_1 dots a_i v_i=v):\nboxedq^F_R_1 = f^F_a_i circ f^F_a_i-1circdots circ f^F_a_1(q^F_o)\nFor all v-d path R_2 = (v=v_0 a_1 v_1 dots a_j v_j=d):\nboxedq^B_R_2 = f^B_a_1 circ f^B_a_2circdots circ f^B_a_j(q^B_d)","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"","category":"page"},{"location":"math/#Algorithms","page":"Theoretical framework","title":"Algorithms","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We first assume that we have accesss to a lower bound b^B_vin Q^B for every vertex v, such that b^B_vleq^B q^B_R for all v-d path R.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Lemma 1 (Cut using bounds) : let R_1 an o-v path. Then :\nforall P = (R_1 R_2)in mathcalP_od c(q^F_R_1 b^B_v)leq c_P\nLemma 2 (Dominance) : if q^F_R_1 leq^F q^F_R_1, then for all R_2 :\nc(q^F_R_1 q^B_R_2)leq c(q^F_R_1 q^B_R_2)\ni.e. (P=(R_1 R_2) P=(R_1 R_2))\nc_P leq c_P","category":"page"},{"location":"math/#Generalized-A\\star","page":"Theoretical framework","title":"Generalized A^star","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Initialization :\nL leftarrow textChemin vide en o: partial paths to process\nM_v leftarrow  q_o^F if v=o, emptyset else\nc^star = +infty\nP^star = textNone\nWhile L neq emptyset\nExtract from L an o-v path P minimizing c(q^F_P b^B_v)\nExtend P : For all ain delta^+(v)\nQ leftarrow P + a (w destination vertex of q)\nq^F_Q leftarrow f^F_a(q^F_P)\nIf w = d and c_Q  c^star\nc^star leftarrow c_q\nP^star leftarrow Q\nElse, if q^F_q is not dominated by any path in M_w and c(q^F_Q b^B_w)  c^star\nAdd q^F_Q to M_w\nRemove from M_w every path dominated by Q\nAdd Q to L","category":"page"},{"location":"math/#Computing-bounds","page":"Theoretical framework","title":"Computing bounds","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Generalized dynamic programming equation in b^B:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"boxedleftbeginaligned\n b_d = q_d\n b_v = bigwedge_substacka = (v w) aindelta^+(v) f^B_a(b_w)\nendalignedright","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"example : when (f^F_a(x) = )f^B_a(x) = c_a + x and wedge = min then b_v = min_a c_a + b_w","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"implies Iterative algorithm along inverse topological order","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Proposition : the solution is a lower bound (it's even the greater: q_b_v = bigwedgelimits_pinmathcalP_vdq^B_p)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConstrainedShortestPaths","category":"page"},{"location":"#ConstrainedShortestPaths.jl","page":"Home","title":"ConstrainedShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements general algorithms for solving Generalized Resource Constrained Shortest Paths problems. It implements a simplified version of the framework from Parmentier 2017, restricted to acyclic directed graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install this package, open a julia Pkg REPL and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/BatyLeo/ConstrainedShortestPaths.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is in a development stage, use it at your own risk!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for ConstrainedShortestPaths.","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/test/tutorial.jl\"","category":"page"},{"location":"tutorial/#Using-built-in-wrappers","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"","category":"section"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"At the moment, this library provides wrappers for two problems: the usual shortest path and resource constrained shortest path.","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"# Import relevant packages\nusing ConstrainedShortestPaths\nusing Graphs, SparseArrays\nusing Plots, GraphRecipes","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"Let's create a simple graph in order to test our wrappers:","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)\ngraphplot(\n    graph,\n    x=[0, 1, 1, 2], y=[0, 1, -1, 0], curves=false,\n    nodecolor=:green, nodesize=0.3,\n    nodeshape=:circle, linewidth=3,\n    names=1:nb_vertices, fontsize=15,\n    edgelabel=d,\n)","category":"page"},{"location":"tutorial/#Usual-shortest-path","page":"Using built-in wrappers","title":"Usual shortest path","text":"","category":"section"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"The usual shortest path on our graph is (1, 2, 3, 4), with length 1.","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"p_star, c_star = basic_shortest_path(graph, d)\n@info \"Solution found\" p_star c_star","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"Note: for the usual shortest path, it's probably better to use directly one of the shortest paths algorithms from Graphs.jl","category":"page"},{"location":"tutorial/#Resource-constrained-shortest-path","page":"Using built-in wrappers","title":"Resource constrained shortest path","text":"","category":"section"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"We now add resource costs w_a on edges, and a resource constraint of the form: sumlimits_ain P w_a leq W","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"W = [1.0]\n\ncost_list = [[0.], [0.], [10.], [0.], [0]]\nw = [0. for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), k) in zip(edge_list, cost_list)\n    w[i, j, :] = k\nend","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"With these costs, the optimal path should be [1, 2, 4], with length 2.","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"p_star, c_star = resource_shortest_path(graph, W, d, w)\n@info \"Solution found\" p_star c_star","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"","category":"page"},{"location":"tutorial/","page":"Using built-in wrappers","title":"Using built-in wrappers","text":"This page was generated using Literate.jl.","category":"page"}]
}
