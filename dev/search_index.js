var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ConstrainedShortestPaths]","category":"page"},{"location":"api/#ConstrainedShortestPaths.PiecewiseLinear","page":"API reference","title":"ConstrainedShortestPaths.PiecewiseLinear","text":"PiecewiseLinear\n\nType used to represent increasing piecewise linear functions, with starting slope 0.\n\nAttributes\n\nfinal_slope::Float64: (positive) slope of the last linear piece.\nbreak_x::Vector{Float64}: (ordered) list of all break points x-coordinates.\nbreak_y::Vector{Float64}: (non decreasing) list of all break points y-coordinates   corresponding to break_x elementwise.\n\n\n\n\n\n","category":"type"},{"location":"api/#ConstrainedShortestPaths.PiecewiseLinear-Tuple{Real}","page":"API reference","title":"ConstrainedShortestPaths.PiecewiseLinear","text":"(f)(x)\n\nReturns f(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.RCSPInstance","page":"API reference","title":"ConstrainedShortestPaths.RCSPInstance","text":"RCSPInstance{G,FR,BR,C,FF,BF}\n\nAttributes\n\ngraph:\norigin_forward_resource:\ndestination_backward_resource:\ncost_function:\nforward_functions:\nbackward_functions:\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.:+-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"Base.:+","text":"+(f1, f2)\n\nReturn a PiecewiseLinear corresponding to f1 + f2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.basic_shortest_path-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, G, AbstractMatrix}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.basic_shortest_path","text":"basic_shortest_path(g, distmx=weights(g))\n\nCompute shortest path between first and last vertices of graph g.\n\nArguments\n\ng::AbstractGraph: acyclic directed graph.\ndistmx::AbstractMatrix: distmx[i, j] corresponds to the distance between vertices i and j   along edge (i, j) of g.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.closest_break_point-Tuple{AbstractVector, Real}","page":"API reference","title":"ConstrainedShortestPaths.closest_break_point","text":"closest_break_point(break_x, x)\n\nFind the index of the closest break point from x. (at its right i fright=true else at its left)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.compose-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"ConstrainedShortestPaths.compose","text":"compose(f1, f2)\n\nReturn a PiecewiseLinear corresponding to f1 ∘ f2 ! only support functions with only one break point and final slope 1\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.compute_bounds-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, RCSPInstance{G}}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.compute_bounds","text":"compute_bounds(instance)\n\naa\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_A_star-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, RCSPInstance{G}, AbstractVector}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.generalized_A_star","text":"generalized_A_star(instance, bounds)\n\naa\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_constrained_shortest_path-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, RCSPInstance{G}}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.generalized_constrained_shortest_path","text":"generalized_constrained_shortest_path(instance)\n\nCompute shortest path between first and last nodes of instance\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.get_points-Tuple{PiecewiseLinear, PiecewiseLinear, Int64, Int64}","page":"API reference","title":"ConstrainedShortestPaths.get_points","text":"get_points(f1, f2, i1, i2)\n\nReturn break point i1 of f1 and break point i2 of f2. If i1 or i2 are out of range, return a border (x, f(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.get_x-Tuple{PiecewiseLinear, Int64}","page":"API reference","title":"ConstrainedShortestPaths.get_x","text":"get_x(f, i; x_max=1000)\n\nReturn x coordinate of breakpoint i. If i is out of range, return xmax\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.intersection-Tuple{PiecewiseLinear, PiecewiseLinear, Int64, Int64}","page":"API reference","title":"ConstrainedShortestPaths.intersection","text":"intersection(f1, f2, i1, i2)\n\nReturn -1 if there is no intersection else the x coordinate of the intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.meet-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"ConstrainedShortestPaths.meet","text":"meet(f1, f2)\n\nCompute the minimum of two PiecewiseLinear functions Return a PiecewiseLinear f, such that ∀x, f(x) = min(f1(x), f2(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.resource_shortest_path-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, G, AbstractVector, AbstractMatrix, Array{Float64, 3}}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.resource_shortest_path","text":"resource_shortest_path(g, distmx, costmx)\n\nCompute resource contrained shortest path between first and last vertices of graph g.\n\nArguments\n\ng::AbstractGraph: acyclic directed graph.\nmax_costs::AbstractVector: list of upper bounds for each resource constraint.\ndistmx::AbstractMatrix: distmx[i, j] corresponds to the distance between vertices i and j   along edge (i, j) of g.\ncostmx::Array{Float64, 3}: cost_mx[i, j, k] corresponds to the resource cost of edge (i, j) for the kth resource constraint.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.stochastic_routing_shortest_path-Union{Tuple{G}, Tuple{Type{Graphs.IsDirected{G}}, G, AbstractMatrix, AbstractMatrix, AbstractVector}} where G<:Graphs.AbstractGraph","page":"API reference","title":"ConstrainedShortestPaths.stochastic_routing_shortest_path","text":"stochastic_routing_shortest_path(g, slacks, delays)\n\nCompute stochastic routing shortest path between first and last vertices of graph g.\n\nArguments\n\ng::AbstractGraph: acyclic directed graph.\nslacks: slacks[i, j] corresponds to the time slack between i and j.\ndelays: delays[i, ω] corresponds to delay of i for scenario ω.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/docs/src/literate/stochastic_vsp.jl\"","category":"page"},{"location":"stochastic_vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Usual-shortest-path","page":"Examples","title":"Usual shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B","category":"page"},{"location":"examples/#Usual-resource-constrained-shortest-path","page":"Examples","title":"Usual resource constrained shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B + mathbbI_q^F + q^B leq W","category":"page"},{"location":"examples/#Stochastic-routing","page":"Examples","title":"Stochastic routing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"c_p = mathbbEsum_vin pR_v = sum_vin p mathbbER_v = sum_vin pfrac1msum_j=1^mR_v^j (m scenarios)\ns_a=(uv) : slack between u and v\na=(uv) rightarrow R_v^j = max(R_u^j - s_uv 0) + varepsilon_v^j\nq^F_u = beginbmatrixC R_u^1 vdots  R_u^mendbmatrixin mathbbR_+^m+1, q^B_v = beginbmatrixg^1 vdots  g^mendbmatrixin (mathbbR_+^mathbbR_+)^m\nq^F_o = 0 q^B_d = 0mapsto 0\nf^F_a=(u v)(q_u^F) = beginbmatrixC + frac1msum_j=1^m R_v^j R_v^1 = max(R_u^1 - S_a 0) + varepsilon_v^1 vdots  R_v^m = max(R_u^m - S_a 0) + varepsilon_v^mendbmatrix\nLet r_a=(uv)^j(R) = max(R - S_a 0) + varepsilon_v^j\nf^B_a=(uv)(q_v^B) = beginbmatrixRmapsto r_a^1(R) + g^1(r_a^1(R))  vdots  Rmapsto r_a^m(R) + g^m(r_a^m(R))endbmatrix\ncleft(beginbmatrixC R_u^1 vdots  R_u^mendbmatrix beginbmatrixg^1 vdots  g^mendbmatrixright) = C + frac1msum_j=1^m g^j(R^j_u)","category":"page"},{"location":"setting/#Setting","page":"Setting","title":"Setting","text":"","category":"section"},{"location":"setting/","page":"Setting","title":"Setting","text":"This page explains the mathematical framework used by ConstrainedShortestPath.jl, and its application to a few examples It's simplified version of the framework from Parmentier 2017, retricted to acyclic graphs.","category":"page"},{"location":"setting/#Generalized-constrained-shortest-path:-problem-formulation","page":"Setting","title":"Generalized constrained shortest path: problem formulation","text":"","category":"section"},{"location":"setting/","page":"Setting","title":"Setting","text":"Let D = (V A) be an acyclic digraph. Let o d two vertices, and mathcalP_od the set of o-d path in D. We want to find a path P^star inmathcalP_od minimizing a given cost function Pmapsto c_P:","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"boxedmin_PinmathcalP_odc_P","category":"page"},{"location":"setting/#Setting-2","page":"Setting","title":"Setting","text":"","category":"section"},{"location":"setting/","page":"Setting","title":"Setting","text":"We define the two following set of resources:","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"Set of forward resources Q^F, with a partial order leq^F\nSet of backward resources Q^B, with a partial order leq^B","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"A partially ordered set (Sleq) is a lattice if any pair s sin S, admits a greatest lower bound swedge s, i.e. forall b st  b leq s and bleq s bleq swedge s.","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"(Q^F leq^F) and (Q^B leq^B) are lattice.","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"For every arc ain A, we define two functions:","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"Forward extension function : f^F_aQ^F to Q^F increasing\nBackward extension function : f^B_a  Q^B to Q^B increasing","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"We also define:","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"A cost function : cQ^Ftimes Q^B to mathbbRcup+infty increasing\nAn origin vertex o, with a corresponding ressource q^F_oin Q^F\nA destination vertex d, with a corresponding ressource q^B_din Q^B","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"Finally need the following (equivalent) properties to hold:","category":"page"},{"location":"setting/","page":"Setting","title":"Setting","text":"For all o-d path P = (o=v_0 a_1 v_1 dots a_k v_k=d), we have :\nboxedforall i iin k c(f^F_i circ f^F_i-1circdotscirc f^F_1(q^F_o) f^B_i+1 circ f^B_i+2circdotscirc f^B_k(q^B_d)) = c_PinmathbbRcup+infty\nFor all o-d path P and every decomposition of P as (R_1 R_2), we have c_P=c(q^F_R_1 q^B_R_2), with:\nFor all o-v path R_1 = (o=v_0 a_1 v_1 dots a_i v_i=v):\nboxedq^F_R_1 = f^F_a_i circ f^F_a_i-1circdots circ f^F_a_1(q^F_o)\nFor all v-d path R_2 = (v=v_0 a_1 v_1 dots a_j v_j=d):\nboxedq^B_R_2 = f^B_a_1 circ f^B_a_2circdots circ f^B_a_j(q^B_d)","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/docs/src/literate/basic_shortest_path.jl\"","category":"page"},{"location":"basic_shortest_path/#Usual-shortest-path","page":"Usual shortest path","title":"Usual shortest path","text":"","category":"section"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"o-d path, K resources","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"boxedmin_pin mathcalP_od sum_ain p d_a","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"# Import relevant packages\nusing ConstrainedShortestPaths\nusing Graphs, SparseArrays\nusing Random\nRandom.seed!(67);\nnothing #hide","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"function random_acyclic_digraph(nb_vertices::Integer; p=0.4)\n    edge_list = []\n    for u in 1:nb_vertices\n        if u < nb_vertices\n            push!(edge_list, (u, u+1))\n        end\n\n        for v in (u+2):nb_vertices\n            if rand() <= p\n                push!(edge_list, (u, v))\n            end\n        end\n    end\n    return SimpleDiGraph(Edge.(edge_list))\nend;\nnothing #hide","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"Let's create a random acyclic directed graph","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"nb_vertices = 50\ng = random_acyclic_digraph(nb_vertices)\nadjacency_matrix(g)","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"distance_list = [rand() * 20 - 5 for _ in 1:ne(g)]\nI = [src(e) for e in edges(g)]\nJ = [dst(e) for e in edges(g)]\nd = sparse(I, J, distance_list);\nnothing #hide","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"aaa","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"p_star, c_star = basic_shortest_path(g, d)\n@info \"Solution found\" c_star p_star'","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"p = enumerate_paths(bellman_ford_shortest_paths(g, 1, d), nb_vertices)\nc = sum(d[p[i], p[i+1]] for i in eachindex(p[1:end-1]))\n@info \"Bellman\" c p'","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"note: Note\nFor the usual shortest path, it's probably better to use directly one of the shortest paths algorithms from Graphs.jl","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"This page was generated using Literate.jl.","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/docs/src/literate/custom.jl\"","category":"page"},{"location":"custom/#Implement-a-custom-problem","page":"Implement a custom problem","title":"Implement a custom problem","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"warning: Warning\nWork in progress","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"using ConstrainedShortestPaths\nusing Graphs, SparseArrays\nimport Base: <=, minimum","category":"page"},{"location":"custom/#Resources","page":"Implement a custom problem","title":"Resources","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct Resource\n    c::Float64\n    w::Float64\nend","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"function <=(r1::Resource, r2::Resource)\n    return r1.c <= r2.c && r1.w <= r2.w\nend\n\nfunction minimum(R::Vector{Resource})\n    return Resource(minimum(r.c for r in R), minimum(r.w for r in R))\nend","category":"page"},{"location":"custom/#Expansion-functions","page":"Implement a custom problem","title":"Expansion functions","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct ExpansionFunction\n    c::Float64\n    w::Float64\nend\n\nfunction (f::ExpansionFunction)(q::Resource)\n    return Resource(f.c + q.c, f.w + q.w)\nend","category":"page"},{"location":"custom/#Cost-function","page":"Implement a custom problem","title":"Cost function","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct Cost\n    W::Float64\nend\n\nfunction (cost::Cost)(fr::Resource, br::Resource)\n    return fr.w + br.w <= cost.W ? fr.c + br.c : Inf\nend","category":"page"},{"location":"custom/#Test","page":"Implement a custom problem","title":"Test","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)\n\nW = 1.0\n\ncost_list = [[0.], [0.], [10.], [0.], [0]]\nw = [0. for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), k) in zip(edge_list, cost_list)\n    w[i, j, :] = k\nend\n\n# origin forward resource and backward forward resource set to 0\nresource = Resource(0., 0.)\n\n# forward and backward expansion functions are equal\nIf = [src(e) for e in edges(graph)]\nJf = [dst(e) for e in edges(graph)]\nf = [ExpansionFunction(d[i, j], w[i, j]) for (i, j) in zip(If, Jf)]\nF = sparse(If, Jf, f);\n\ninstance = RCSPInstance(graph, resource, resource, Cost(W), F, F)\np_star, c_star = generalized_constrained_shortest_path(instance)","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"EditURL = \"https://github.com/BatyLeo/ConstrainedShortestPaths.jl/blob/main/docs/src/literate/resource_shortest_path.jl\"","category":"page"},{"location":"resource_shortest_path/#Resource-constrained-shortest-path","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"","category":"section"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"o-d path, K resources","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"boxedbeginaligned\nmin_pin mathcalP_od  sum_ain p d_a  \nst  sum_ain p w_a^k leq W^k  forall k in K\nendaligned","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"using ConstrainedShortestPaths\nusing Graphs, SparseArrays\nusing GLMakie, GraphMakie","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"Let's create a simple graph in order to test our wrappers:","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"We now add resource costs w_a on edges, and a resource constraint of the form: sumlimits_ain P w_a leq W","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"W = [1.]\ncost_list = [[0], [0], [10], [0], [0]]\nw = [0. for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), c) in zip(edge_list, cost_list)\n    w[i, j, :] = c\nend\n\ngraphplot(graph;\n    node_color=:red,\n    nlabels=[\"$i\" for i in 1:nb_vertices],\n    elabels=[\"d=$(d[e.src, e.dst]), w=$(w[e.src, e.dst, :])\" for e in edges(graph)]\n)","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"With these costs, the optimal path should be [1, 2, 4], with length 2.","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"p_star, c_star = resource_shortest_path(graph, W, d, w)\n@info \"Solution found\" p_star c_star","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"","category":"page"},{"location":"resource_shortest_path/","page":"Resource constrained shortest path","title":"Resource constrained shortest path","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConstrainedShortestPaths","category":"page"},{"location":"#ConstrainedShortestPaths.jl","page":"Home","title":"ConstrainedShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"warning: Warning\nThis package is still in a development stage, use it at your own risk!","category":"page"},{"location":"","page":"Home","title":"Home","text":"ConstrainedShortestPaths is a package for solving Generalized Resource Constrained Shortest Paths problems. It implements a simplified version of the framework from Parmentier 2017, restricted to acyclic directed graphs.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, open a julia REPL and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"]add https://github.com/BatyLeo/ConstrainedShortestPaths.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"#Advanced-usage","page":"Home","title":"Advanced usage","text":"","category":"section"},{"location":"algorithms/#Algorithms","page":"Algorithms","title":"Algorithms","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"We first assume that we have accesss to a lower bound b^B_vin Q^B for every vertex v, such that b^B_vleq^B q^B_R for all v-d path R.","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Lemma 1 (Cut using bounds) : let R_1 an o-v path. Then :\nforall P = (R_1 R_2)in mathcalP_od c(q^F_R_1 b^B_v)leq c_P\nLemma 2 (Dominance) : if q^F_R_1 leq^F q^F_R_1, then for all R_2 :\nc(q^F_R_1 q^B_R_2)leq c(q^F_R_1 q^B_R_2)\ni.e. (P=(R_1 R_2) P=(R_1 R_2))\nc_P leq c_P","category":"page"},{"location":"algorithms/#Generalized-A\\star","page":"Algorithms","title":"Generalized A^star","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Initialization :\nL leftarrow textChemin vide en o: partial paths to process\nM_v leftarrow  q_o^F if v=o, emptyset else\nc^star = +infty\nP^star = textNone\nWhile L neq emptyset\nExtract from L an o-v path P minimizing c(q^F_P b^B_v)\nExtend P : For all ain delta^+(v)\nQ leftarrow P + a (w destination vertex of q)\nq^F_Q leftarrow f^F_a(q^F_P)\nIf w = d and c_Q  c^star\nc^star leftarrow c_q\nP^star leftarrow Q\nElse, if q^F_q is not dominated by any path in M_w and c(q^F_Q b^B_w)  c^star\nAdd q^F_Q to M_w\nRemove from M_w every path dominated by Q\nAdd Q to L","category":"page"},{"location":"algorithms/#Computing-bounds","page":"Algorithms","title":"Computing bounds","text":"","category":"section"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Generalized dynamic programming equation in b^B:","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"boxedleftbeginaligned\n b_d = q_d\n b_v = bigwedge_substacka = (v w) aindelta^+(v) f^B_a(b_w)\nendalignedright","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"example : when (f^F_a(x) = )f^B_a(x) = c_a + x and wedge = min then b_v = min_a c_a + b_w","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"implies Iterative algorithm along inverse topological order","category":"page"},{"location":"algorithms/","page":"Algorithms","title":"Algorithms","text":"Proposition : the solution is a lower bound (it's even the greater: q_b_v = bigwedgelimits_pinmathcalP_vdq^B_p)","category":"page"}]
}
