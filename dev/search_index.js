var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ConstrainedShortestPaths]","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/#Usual-shortest-path","page":"Examples","title":"Usual shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B","category":"page"},{"location":"examples/#Usual-resource-constrained-shortest-path","page":"Examples","title":"Usual resource constrained shortest path","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B + mathbbI_q^F + q^B leq W","category":"page"},{"location":"examples/#Stochastic-routing","page":"Examples","title":"Stochastic routing","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"warning: Coming soon\n","category":"page"},{"location":"custom/#Implementing-a-custom-problem","page":"Implementing a custom problem","title":"Implementing a custom problem","text":"","category":"section"},{"location":"custom/","page":"Implementing a custom problem","title":"Implementing a custom problem","text":"warning: Coming soon\n","category":"page"},{"location":"math/#Theoretical-framework","page":"Theoretical framework","title":"Theoretical framework","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"This page explains the mathematical framework used by ConstrainedShortestPath.jl, and its application to a few examples It's simplified version of the framework from Parmentier 2017, retricted to acyclic graphs.","category":"page"},{"location":"math/#Generalized-constrained-shortest-path","page":"Theoretical framework","title":"Generalized constrained shortest path","text":"","category":"section"},{"location":"math/#Problem-formulation","page":"Theoretical framework","title":"Problem formulation","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Let D = (V A) be an acyclic digraph. Let o d two vertices, and mathcalP_od the set of o-d path in D. We want to find a path in P^star inmathcalP_od minimizing a cost function Pmapsto c_P:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"boxedmin_PinmathcalP_odc_P","category":"page"},{"location":"math/#Setting","page":"Theoretical framework","title":"Setting","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We define the two following set of resources:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Set of forward resources Q^F, with a partial order leq^F\nSet of backward resources Q^B, with a partial order leq^B","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"A partially ordered set (Sleq) is a lattice if any pair s sin S, admits a greatest lower bound swedge s, i.e. forall b bleq swedge s, b leq s and bleq s.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"(Q^F leq^F) and (Q^B leq^B) are lattice.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"For every arc ain A, we define two functions:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Forward extension function : f^F_aQ^F to Q^F increasing\nBackward extension function : f^B_a  Q^B to Q^B increasing","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We also define:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"A cost function : cQ^Ftimes Q^B to mathbbRcup+infty increasing\nAn origin vertex o, with a corresponding ressource q^F_oin Q^F\nA destination vertex d, with a corresponding ressource q^B_din Q^B","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Finally need the following (equivalent) properties to hold:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"For all o-d path P = (o=v_0 a_1 v_1 dots a_k v_k=d), we have :\nboxedforall i iin k c(f^F_i circ f^F_i-1circdotscirc f^F_1(q^F_o) f^B_i+1 circ f^B_i+2circdotscirc f^B_k(q^B_d)) = c_PinmathbbRcup+infty\nFor all o-d path P and every decomposition of P as (R_1 R_2), we have c_P=c(q^F_R_1 q^B_R_2), with:\nFor all o-v path R_1 = (o=v_0 a_1 v_1 dots a_i v_i=v):\nboxedq^F_R_1 = f^F_a_i circ f^F_a_i-1circdots circ f^F_a_1(q^F_o)\nFor all v-d path R_2 = (v=v_0 a_1 v_1 dots a_j v_j=d):\nboxedq^B_R_2 = f^B_a_1 circ f^B_a_2circdots circ f^B_a_j(q^B_d)","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"","category":"page"},{"location":"math/#Algorithms","page":"Theoretical framework","title":"Algorithms","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"We first assume that we have accesss to a lower bound b^B_vin Q^B for every vertex v, such that b^B_vleq^B q^B_R for all v-d path R.","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Lemma 1 (Cut using bounds) : let R_1 an o-v path. Then :\nforall P = (R_1 R_2)in mathcalP_od c(q^F_R_1 b^B_v)leq c_P\nProof : b^B_vleq^B q^B_R_2 implies c(q^F_R_1 b^B_v) leq c(q^F_R_1 q^B_R_2) par croissance de c\nLemma 2 (Dominance) : if q^F_R_1 leq^F q^F_R_1, then for all R_2 :\nc(q^F_R_1 q^B_R_2)leq c(q^F_R_1 q^B_R_2)\ni.e. (P=(R_1 R_2) P=(R_1 R_2))\nc_P leq c_P","category":"page"},{"location":"math/#Generalized-A\\star","page":"Theoretical framework","title":"Generalized A^star","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Initialization :\nL leftarrow textChemin vide en o: partial paths to process\nM_v leftarrow  q_o^F if v=o, emptyset else\nc^star = +infty\nP^star = textNone\nWhile L neq emptyset\nExtract from L an o-v path P minimizing c(q^F_P b^B_v)\nExtend P : For all ain delta^+(v)\nQ leftarrow P + a (w destination vertex of q)\nq^F_Q leftarrow f^F_a(q^F_P)\nIf w = d and c_Q  c^star\nc^star leftarrow c_q\nP^star leftarrow Q\nElse, if q^F_q is not dominated by any path in M_w and c(q^F_Q b^B_w)  c^star\nAdd q^F_Q to M_w\nRemove from M_w every path dominated by Q\nAdd Q to L","category":"page"},{"location":"math/#Computing-bounds","page":"Theoretical framework","title":"Computing bounds","text":"","category":"section"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Generalized dynamic programming equation in b^B:","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"boxedleftbeginaligned\n b_d = q_d\n b_v = bigwedge_substacka = (v w) aindelta^+(v) f^B_a(b_w)\nendalignedright","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"example : when (f^F_a(x) = )f^B_a(x) = c_a + x and wedge = min then b_v = min_a c_a + b_w","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"implies Iterative algorithm along inverse topological order","category":"page"},{"location":"math/","page":"Theoretical framework","title":"Theoretical framework","text":"Proposition : the solution is a lower bound (it's even the greater: q_b_v = bigwedgelimits_pinmathcalP_vdq^B_p)","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConstrainedShortestPaths","category":"page"},{"location":"#ConstrainedShortestPaths.jl","page":"Home","title":"ConstrainedShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package implements general algorithms for solving Generalized Resource Constrained Shortest Paths problems. It implements a simplified version of the framework from Parmentier 2017, restricted to acyclic directed graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"To install this package, open a julia Pkg REPL and run the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"pkg> add https://github.com/BatyLeo/ConstrainedShortestPaths.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is in a development stage, use it at your own risk!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Documentation for ConstrainedShortestPaths.","category":"page"},{"location":"tutorial/#Using-implemented-examples","page":"Using implemented examples","title":"Using implemented examples","text":"","category":"section"},{"location":"tutorial/","page":"Using implemented examples","title":"Using implemented examples","text":"warning: Coming soon\n","category":"page"}]
}
