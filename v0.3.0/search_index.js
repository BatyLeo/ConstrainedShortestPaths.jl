var documenterSearchIndex = {"docs":
[{"location":"maths/#Mathematical-background","page":"Mathematical background","title":"Mathematical background","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"This page explains the mathematical framework used by ConstrainedShortestPath.jl, and its application to a few examples It's simplified version of the framework from Parmentier 2017, retricted to acyclic graphs.","category":"page"},{"location":"maths/#Generalized-constrained-shortest-path:-problem-formulation","page":"Mathematical background","title":"Generalized constrained shortest path: problem formulation","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Let D = (V A) be an acyclic digraph. Let o d two vertices, and mathcalPinmathcalP_od a set of o-d path in D. We want to find a path P^star inmathcalP minimizing a given cost function Pmapsto C(P):","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"min_PinmathcalPC(P)","category":"page"},{"location":"maths/#Setting","page":"Mathematical background","title":"Setting","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Before describing the details of the algorithms, we must first define some modeling elements specific to the treated problem.","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"We define the two following sets:\nSet of forward resources Q^F, provided with a partial order leq^F.\nSet of backward resources Q^B, provided with a partial order leq^B.\n(Q^F leq^F) and (Q^B leq^B) should be lattices: a partially ordered set (Sleq) is a lattice if any pair s sin S, admits a greatest lower bound swedge s (i.e. forall bin S (b leq s text and  bleq s) implies bleq swedge s)\nFor every arc ain A, we define two functions:\nA forward extension function : f^F_aQ^F to Q^F, increasing\nA backward extension function : f^B_a  Q^B to Q^B, increasing\nWe also define:\nA cost function : cQ^Ftimes Q^B to mathbbRcup+infty, increasing\nResources corresponding to vertices o an d: q^F_oin Q^F, q^B_din Q^B ","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"All these new theoretical elements should be connected to the initial problem formulation by following one of these (equivalent) properties:","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"For all o-d path P = (o=v_0 a_1 v_1 dots a_k v_k=d), we have :\nforall i iin k c(f^F_i circ f^F_i-1circdotscirc f^F_1(q^F_o) f^B_i+1 circ f^B_i+2circdotscirc f^B_k(q^B_d)) = C(P)inmathbbRcup+infty\nFor all o-d path P and every decomposition of P as (R_1 R_2), we have C(P)=c(q^F_R_1 q^B_R_2), with:\nFor all o-v path R_1 = (o=v_0 a_1 v_1 dots a_i v_i=v):\nq^F_R_1 = f^F_a_i circ f^F_a_i-1circdots circ f^F_a_1(q^F_o)\nFor all v-d path R_2 = (v=v_0 a_1 v_1 dots a_j v_j=d):\nq^B_R_2 = f^B_a_1 circ f^B_a_2circdots circ f^B_a_j(q^B_d)","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"For examples of resources sets, extension and cost functions, checkout the Examples section.","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"","category":"page"},{"location":"maths/#Algorithms","page":"Mathematical background","title":"Algorithms","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"We first assume that we have accesss to a lower bound b^B_vin Q^B for every vertex v, such that b^B_vleq^B q^B_R for all v-d path R.","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Lemma 1 (Cut using bounds) : let R_1 an o-v path. Then :\nforall P = (R_1 R_2)in mathcalP_od c(q^F_R_1 b^B_v)leq C(P)\nLemma 2 (Dominance) : if q^F_R_1 leq^F q^F_R_1, then for all R_2 :\nc(q^F_R_1 q^B_R_2)leq c(q^F_R_1 q^B_R_2)\ni.e. C(P) leq C(P) (P=(R_1 R_2) P=(R_1 R_2))","category":"page"},{"location":"maths/#Generalized-A\\star","page":"Mathematical background","title":"Generalized A^star","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Initialization :\nL leftarrow textEmpty path in o: partial paths to process\nM_v leftarrow  q_o^F if v=o, emptyset else\nc^star = +infty\nP^star = textNone\nWhile L neq emptyset\nExtract from L an o-v path P minimizing c(q^F_P b^B_v)\nExtend P : For all ain delta^+(v)\nQ leftarrow P + a (w destination vertex of q)\nq^F_Q leftarrow f^F_a(q^F_P)\nIf w = d and c_Q  c^star\nc^star leftarrow c_q\nP^star leftarrow Q\nElse, if q^F_q is not dominated by any path in M_w and c(q^F_Q b^B_w)  c^star\nAdd q^F_Q to M_w\nRemove from M_w every path dominated by Q\nAdd Q to L","category":"page"},{"location":"maths/#Computing-bounds","page":"Mathematical background","title":"Computing bounds","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Generalized dynamic programming equation in b^B:","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"boxedleftbeginaligned\n b_d = q_d\n b_v = bigwedge_substacka = (v w) aindelta^+(v) f^B_a(b_w)\nendalignedright","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"example : when (f^F_a(x) = )f^B_a(x) = c_a + x and wedge = min then b_v = min_a c_a + b_w","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"implies Iterative algorithm along inverse topological order","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"Proposition : the solution is a lower bound (it's even the greater: q_b_v = bigwedgelimits_pinmathcalP_vdq^B_p)","category":"page"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"","category":"page"},{"location":"maths/#Examples","page":"Mathematical background","title":"Examples","text":"","category":"section"},{"location":"maths/#Shortest-path","page":"Mathematical background","title":"Shortest path","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B","category":"page"},{"location":"maths/#Usual-resource-constrained-shortest-path","page":"Mathematical background","title":"Usual resource constrained shortest path","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"q_o^F = 0 q^B_d = 0\nf^F_a(q) = f^B_a(q) = c_a + q\nc(q^F q^B) = q^F + q^B + mathbbI_q^F + q^B leq W","category":"page"},{"location":"maths/#Stochastic-routing","page":"Mathematical background","title":"Stochastic routing","text":"","category":"section"},{"location":"maths/","page":"Mathematical background","title":"Mathematical background","text":"c_p = mathbbEsum_vin pR_v = sum_vin p mathbbER_v = sum_vin pfrac1msum_j=1^mR_v^j (m scenarios)\ns_a=(uv) : slack between u and v\na=(uv) rightarrow R_v^j = max(R_u^j - s_uv 0) + varepsilon_v^j\nq^F_u = beginbmatrixC R_u^1 vdots  R_u^mendbmatrixin mathbbR_+^m+1, q^B_v = beginbmatrixg^1 vdots  g^mendbmatrixin (mathbbR_+^mathbbR_+)^m\nq^F_o = 0 q^B_d = 0mapsto 0\nf^F_a=(u v)(q_u^F) = beginbmatrixC + frac1msum_j=1^m R_v^j R_v^1 = max(R_u^1 - S_a 0) + varepsilon_v^1 vdots  R_v^m = max(R_u^m - S_a 0) + varepsilon_v^mendbmatrix\nLet r_a=(uv)^j(R) = max(R - S_a 0) + varepsilon_v^j\nf^B_a=(uv)(q_v^B) = beginbmatrixRmapsto r_a^1(R) + g^1(r_a^1(R))  vdots  Rmapsto r_a^m(R) + g^m(r_a^m(R))endbmatrix\ncleft(beginbmatrixC R_u^1 vdots  R_u^mendbmatrix beginbmatrixg^1 vdots  g^mendbmatrixright) = C + frac1msum_j=1^m g^j(R^j_u)","category":"page"},{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#Index","page":"API reference","title":"Index","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"","category":"page"},{"location":"api/#Docstrings","page":"API reference","title":"Docstrings","text":"","category":"section"},{"location":"api/","page":"API reference","title":"API reference","text":"Modules = [ConstrainedShortestPaths]","category":"page"},{"location":"api/#ConstrainedShortestPaths.CSPInstance","page":"API reference","title":"ConstrainedShortestPaths.CSPInstance","text":"CSPInstance{G,FR,BR,C,FF,BF}\n\nAttributes\n\ngraph\norigin_forward_resource\ndestination_backward_resource\ncost_function\nforward_functions\nbackward_functions\n\n\n\n\n\n","category":"type"},{"location":"api/#ConstrainedShortestPaths.PiecewiseLinear","page":"API reference","title":"ConstrainedShortestPaths.PiecewiseLinear","text":"PiecewiseLinear\n\nType used to represent increasing piecewise linear functions, with starting slope 0.\n\nAttributes\n\nfinal_slope::Float64: (positive) slope of the last linear piece.\nbreak_x::Vector{Float64}: (ordered) list of all break points x-coordinates.\nbreak_y::Vector{Float64}: (non decreasing) list of all break points y-coordinates   corresponding to break_x elementwise.\n\n\n\n\n\n","category":"type"},{"location":"api/#ConstrainedShortestPaths.PiecewiseLinear-Tuple{Real}","page":"API reference","title":"ConstrainedShortestPaths.PiecewiseLinear","text":"(f)(x)\n\nReturns f(x).\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.:+-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"Base.:+","text":"+(f1, f2)\n\nReturn a PiecewiseLinear corresponding to f1 + f2.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.basic_shortest_path-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, G, T, T, AbstractMatrix}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.basic_shortest_path","text":"basic_shortest_path(graph, distmx=weights(graph), s, t)\n\nCompute shortest path between vertices s and t of graph graph.\n\nArguments\n\ngraph::AbstractGraph: acyclic directed graph.\ndistmx::AbstractMatrix: distmx[i, j] corresponds to the distance between vertices i and j   along edge (i, j) of graph.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.closest_break_point-Tuple{AbstractVector, Real}","page":"API reference","title":"ConstrainedShortestPaths.closest_break_point","text":"closest_break_point(break_x, x)\n\nFind the index of the closest break point from x. (at its right i fright=true else at its left)\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.compose-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"ConstrainedShortestPaths.compose","text":"compose(f1, f2)\n\nReturn a PiecewiseLinear corresponding to f1 ∘ f2 ! only support functions with only one break point and final slope 1\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.compute_bounds-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, CSPInstance{T, G}}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.compute_bounds","text":"compute_bounds(instance)\n\nCompute backward bounds of instance (see Computing bounds).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_a_star-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, CSPInstance{T, G}, AbstractVector}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.generalized_a_star","text":"generalized_a_star(instance, s, t, bounds)\n\nPerform generalized A star algorithm on instnace using bounds (see Generalized A^\\star).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_a_star_with_threshold-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, CSPInstance{T, G}, AbstractVector, Float64}} where {T, G<:Graphs.AbstractGraph}","page":"API reference","title":"ConstrainedShortestPaths.generalized_a_star_with_threshold","text":"generalized_a_star_with_threshold(instance, bounds, threshold)\n\nCompute all paths below threshold.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_constrained_shortest_path-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, CSPInstance{T, G}}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.generalized_constrained_shortest_path","text":"generalized_constrained_shortest_path(instance, s, t)\n\nCompute the shortest path of instance.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.generalized_constrained_shortest_path_with_threshold-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, CSPInstance{T, G}, Float64}} where {T, G<:Graphs.AbstractGraph}","page":"API reference","title":"ConstrainedShortestPaths.generalized_constrained_shortest_path_with_threshold","text":"generalized_constrained_shortest_path(instance)\n\nCompute shortest path between first and last nodes of instance\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.get_points-Tuple{PiecewiseLinear, PiecewiseLinear, Int64, Int64}","page":"API reference","title":"ConstrainedShortestPaths.get_points","text":"get_points(f1, f2, i1, i2)\n\nReturn break point i1 of f1 and break point i2 of f2. If i1 or i2 are out of range, return a border (x, f(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.get_x-Tuple{PiecewiseLinear, Int64}","page":"API reference","title":"ConstrainedShortestPaths.get_x","text":"get_x(f, i; x_max=1000)\n\nReturn x coordinate of breakpoint i. If i is out of range, return xmax\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.intersection-Tuple{PiecewiseLinear, PiecewiseLinear, Int64, Int64}","page":"API reference","title":"ConstrainedShortestPaths.intersection","text":"intersection(f1, f2, i1, i2)\n\nReturn -1 if there is no intersection else the x coordinate of the intersection.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.meet-Tuple{PiecewiseLinear, PiecewiseLinear}","page":"API reference","title":"ConstrainedShortestPaths.meet","text":"meet(f1, f2)\n\nCompute the minimum of two PiecewiseLinear functions Return a PiecewiseLinear f, such that ∀x, f(x) = min(f1(x), f2(x)).\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.resource_shortest_path-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, G, T, T, AbstractVector, AbstractMatrix, Array{Float64, 3}}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.resource_shortest_path","text":"resource_shortest_path(g, s, t, distmx, costmx)\n\nCompute resource contrained shortest path between vertices s and t of graph g.\n\nArguments\n\ng::AbstractGraph: acyclic directed graph.\nmax_costs::AbstractVector: list of upper bounds for each resource constraint.\ndistmx::AbstractMatrix: distmx[i, j] corresponds to the distance between vertices i and j   along edge (i, j) of g.\ncostmx::Array{Float64, 3}: cost_mx[i, j, k] corresponds to the resource cost of edge (i, j) for the kth resource constraint.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"api/#ConstrainedShortestPaths.stochastic_routing_shortest_path-Union{Tuple{G}, Tuple{T}, Tuple{Type{Graphs.IsDirected{G}}, G, AbstractMatrix, AbstractMatrix, AbstractVector}} where {T, G<:Graphs.AbstractGraph{T}}","page":"API reference","title":"ConstrainedShortestPaths.stochastic_routing_shortest_path","text":"stochastic_routing_shortest_path(graph, slacks, delays)\n\nCompute stochastic routing shortest path between first and last vertices of graph graph.\n\nArguments\n\ngraph::AbstractGraph: acyclic directed graph.\nslacks: slacks[i, j] corresponds to the time slack between i and j.\ndelays: delays[i, ω] corresponds to delay of i for scenario ω.\n\nReturns\n\np_star::Vector{Int}: optimal path found.\nc_star::Float64: length of path p_star.\n\n\n\n\n\n","category":"method"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"EditURL = \"literate/stochastic_vsp.jl\"","category":"page"},{"location":"stochastic_vsp/#Stochastic-Vehicle-Scheduling","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This kind application is the main reason this package was created in the first place.","category":"page"},{"location":"stochastic_vsp/#Problem-definition","page":"Stochastic Vehicle Scheduling","title":"Problem definition","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Vehicle Scheduling involves assigning vehicles to cover a set of scheduled tasks, while minimizing a given objective function.","category":"page"},{"location":"stochastic_vsp/#Deterministic-version","page":"Stochastic Vehicle Scheduling","title":"Deterministic version","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"An instance of the problem is composed of:","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"A set of tasks vinbar V:\nScheduled task begin time: t_v^b\nScheduled task end time: t_v^e ( t_v^b)\nScheduled travel time from task u to task v: t_(u v)^tr\nTask v can be scheduled after task u on a vehicle path only if: t_v^b geq t_u^e + t_(u v)^tr\nObjective to minimize: number of vehicle used","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This problem is very easy to solve using a compact MIP formulation.","category":"page"},{"location":"stochastic_vsp/#Stochastic-version","page":"Stochastic Vehicle Scheduling","title":"Stochastic version","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"The stochastic version is a variation that introduces random delays that occur after the scheduling is fixed. The objective is now to minimize the expectation of the total delay.","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"We add the following to instances:","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Finite set of scenarios Omega.\nWe indroduce three sets of random variables, which take different values depending on   the scenario omegainOmega:\nIntrisic delay of task v: varepsilon_v^omega\nSlack between tasks u and v: S_uv^omega\nGiven an o-uv path P, we define recursively the delay Delta_v^omega of task v in   scenario omega  along P:","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"boxedDelta_v^ω = ε_v^omega + max(Delta_u^omega - S_uv^omega 0)","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Objective to minimize: dfrac1Omegasumlimits_omegainOmega Delta_v^omega","category":"page"},{"location":"stochastic_vsp/#Column-generation-formulation","page":"Stochastic Vehicle Scheduling","title":"Column generation formulation","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"We model an instance by the following acyclic Digraph D = (V A):","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"V = bar Vcup o d, with o and d dummy origin and destination nodes   connected to all tasks:\n(o v) arc for all task vin bar V\n(v d) arc for all task v in bar V\nThere is an arc between tasks u and v only if t_v^b geq t_u^e + t_(u v)^tr","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"A feasible vehicle tour is an o-d path Pinmathcal P_od. A feasible solution is a set of disjoint feasible vehicle tours fulfilling all tasks exctly once.","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Cost of a path P: c_P = dfrac1Omegasumlimits_omegainOmegasumlimits_vin VbackslashodDelta_v^omega","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"beginaligned\nmin  sum_PinmathcalPc_P y_P \ntextst  sum_pni v y_p = 1 forall vin Vbackslasho d  quad(lambda_vinmathbb R)\n y_pin01  forall pin mathcalP \nendaligned","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This formulation can be solved using a column generation algorithm. The associated subproblem is a constrained shortest path problem of the form :","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"boxedmin_Pinmathcal P_od leftc_P  - sum_vin Plambda_vright","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This subproblem can be solved using generalized constrained shortest paths algorithms provided by this package.","category":"page"},{"location":"stochastic_vsp/#Using-ConstrainedShortestPaths","page":"Stochastic Vehicle Scheduling","title":"Using ConstrainedShortestPaths","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"using ConstrainedShortestPaths\nusing GLPK\nusing Graphs\nusing JuMP\nusing Random\nusing SparseArrays","category":"page"},{"location":"stochastic_vsp/#Create-a-random-instance","page":"Stochastic Vehicle Scheduling","title":"Create a random instance","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Random graph acyclic directed graph","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"function random_acyclic_digraph(nb_vertices::Integer; p=0.4)\n    edge_list = []\n    for u in 1:nb_vertices\n        for v in (u + 1):(u == 1 ? nb_vertices - 1 : nb_vertices)\n            if rand() <= p\n                push!(edge_list, (u, v))\n            end\n        end\n    end\n    for i in 2:(nb_vertices - 1)\n        push!(edge_list, (1, i))\n        push!(edge_list, (i, nb_vertices))\n    end\n    return SimpleDiGraph(Edge.(edge_list))\nend\n\nRandom.seed!(67)\nnb_vertices = 30\nnb_scenarios = 10\ngraph = random_acyclic_digraph(nb_vertices)","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"Random delays and slacks matrices:","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"nb_edges = ne(graph)\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\n\ndelays = rand(nb_vertices, nb_scenarios) * 10\ndelays[end, :] .= 0.0\nslacks = [\n    if dst(e) == nb_vertices\n        [Inf for _ in 1:nb_scenarios]\n    else\n        [rand() * 10 for _ in 1:nb_scenarios]\n    end for e in edges(graph)\n]\nslack_matrix = sparse(I, J, slacks);\n\n# Path cost computation\nfunction path_cost(path, slacks, delays)\n    nb_scenarios = size(delays, 2)\n    old_v = path[1]\n    R = delays[old_v, :]\n    C = 0.0\n    for v in path[2:(end - 1)]\n        @. R = max(R - slacks[old_v, v], 0) + delays[v, :]\n        C += sum(R) / nb_scenarios\n        old_v = v\n    end\n    return C\nend","category":"page"},{"location":"stochastic_vsp/#Column-generation-algorithm","page":"Stochastic Vehicle Scheduling","title":"Column generation algorithm","text":"","category":"section"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"We use the dual formulation with constraints generation:","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"function column_generation(g, slacks, delays)\n    nb_vertices = nv(g)\n    job_indices = 2:(nb_vertices - 1)\n\n    model = Model(GLPK.Optimizer)\n\n    @variable(model, λ[v in 1:nb_vertices])\n\n    @objective(model, Max, sum(λ[v] for v in job_indices))\n\n    # Initialize constraints set with all [o, v, d] paths\n    initial_paths = [[1, v, nb_vertices] for v in 2:(nb_vertices - 1)]\n    @constraint(\n        model,\n        con[p in initial_paths],\n        path_cost(p, slacks, delays) - sum(λ[v] for v in job_indices if v in p) >= 0\n    )\n    @constraint(model, λ[1] == 0)\n    @constraint(model, λ[nb_vertices] == 0)\n\n    while true\n        # Solve the master problem\n        optimize!(model)\n        λ_val = value.(λ)\n        # Solve the shortest path subproblem\n        (; c_star, p_star) = stochastic_routing_shortest_path(g, slacks, delays, λ_val)\n        if c_star > -1e-10\n            break\n        end\n        full_cost = c_star + sum(λ_val[v] for v in job_indices if v in p_star)\n        # Add the most violated constraint\n        @constraint(model, full_cost - sum(λ[v] for v in job_indices if v in p_star) >= 0)\n    end\n\n    return objective_value(model)\nend\n\nobj = column_generation(graph, slack_matrix, delays)\n@info \"Objective value\" obj","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"","category":"page"},{"location":"stochastic_vsp/","page":"Stochastic Vehicle Scheduling","title":"Stochastic Vehicle Scheduling","text":"This page was generated using Literate.jl.","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"EditURL = \"literate/basic_shortest_path.jl\"","category":"page"},{"location":"basic_shortest_path/#Usual-shortest-path","page":"Usual shortest path","title":"Usual shortest path","text":"","category":"section"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"In this first tutorial, we will use the basic_shortest_path method to solve the usual shortest path problem (no constraints and linear cost) :","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"min_Pin mathcalP_od sum_ain P c_a","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"note: Note\nThis example is mainly for tutorial purposes. You will achieve better performance by using  directly one of the shortest paths algorithms from Graphs.jl or implementing your own Dijkstra/dynamic programming algorithm.","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"Let's import the package, and fix the seed for reproducibility.","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"using ConstrainedShortestPaths\nusing Random\n\nRandom.seed!(67)\ninclude(\"utils.jl\"); # imports random_acyclic_digraph\nnothing #hide","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"We wreate a random acyclic directed graph","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"nb_vertices = 50\ng = random_acyclic_digraph(nb_vertices)","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"The adjacency matrix is triangular","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"adjacency_matrix(g)","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"Create a cost matrix with random values","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"using SparseArrays\ndistance_list = [rand() * 20 - 5 for _ in 1:ne(g)]\nI = [src(e) for e in edges(g)]\nJ = [dst(e) for e in edges(g)]\ncost_matrix = sparse(I, J, distance_list);\nnothing #hide","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"Compute the shortest path","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"p_star, c_star = basic_shortest_path(g, 1, nb_vertices, cost_matrix)\n@info \"Solution found\" c_star p_star'","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"We can check that we obtain the same results with the dynamic programming algorithm from Graphs.jl","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"p = enumerate_paths(bellman_ford_shortest_paths(g, 1, cost_matrix), nb_vertices)\nc = sum(cost_matrix[p[i], p[i + 1]] for i in eachindex(p[1:(end - 1)]))\n@info \"Bellman\" c p'","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"","category":"page"},{"location":"basic_shortest_path/","page":"Usual shortest path","title":"Usual shortest path","text":"This page was generated using Literate.jl.","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"EditURL = \"literate/custom.jl\"","category":"page"},{"location":"custom/#Implement-a-custom-problem","page":"Implement a custom problem","title":"Implement a custom problem","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"In this tutorial, you will learn how to use this package to solve your own custom constrained shortest path problem.","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"First of all, make sure you read the Mathematical background. In order to use the generalized_constrained_shortest_path on your custom problem, you need to define a few different types and methods:","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"Types that need to be implemented:\nResources types (backward and forward)\nExpansion functions (backward and forward)\nMethods that need to be implemented:\nBase.<= between two forward resources\nBase.minimum of a vector of backward resources\nMake forward functions callable on forward resources\nMake backward function callable on backward resources\nA callable cost function","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"You can checkout examples already implemented in the src/examples folder of this package.","category":"page"},{"location":"custom/#Example-on-the-unidimensional-resource-shortest-path","page":"Implement a custom problem","title":"Example on the unidimensional resource shortest path","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"We illustrate this on the same problem a in Shortest path with linear resource constraints but simplified with only one constraint.","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"using ConstrainedShortestPaths\nusing Graphs, SparseArrays\nimport Base: <=, minimum","category":"page"},{"location":"custom/#Resources","page":"Implement a custom problem","title":"Resources","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"Forward and backward resources for this example are in the same space:","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct Resource\n    c::Float64\n    w::Float64\nend","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"Base.<= and Base.minimum","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"function <=(r1::Resource, r2::Resource)\n    return r1.c <= r2.c && r1.w <= r2.w\nend\n\nfunction minimum(R::Vector{Resource})\n    return Resource(minimum(r.c for r in R), minimum(r.w for r in R))\nend","category":"page"},{"location":"custom/#Expansion-functions","page":"Implement a custom problem","title":"Expansion functions","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct ForwardExpansionFunction\n    c::Float64\n    w::Float64\nend\n\nfunction (f::ForwardExpansionFunction)(q::Resource; W)\n    return Resource(f.c + q.c, f.w + q.w), f.w + q.w <= W\nend\n\nstruct BackwardExpansionFunction\n    c::Float64\n    w::Float64\nend\n\nfunction (f::BackwardExpansionFunction)(q::Resource; W)\n    return Resource(f.c + q.c, f.w + q.w)\nend","category":"page"},{"location":"custom/#Cost-function","page":"Implement a custom problem","title":"Cost function","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"struct Cost end\n\nfunction (cost::Cost)(fr::Resource, br::Resource)\n    return fr.c + br.c\nend","category":"page"},{"location":"custom/#Test-on-an-instance","page":"Implement a custom problem","title":"Test on an instance","text":"","category":"section"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)\n\nW = 1.0\n\ncost_list = [[0.0], [0.0], [10.0], [0.0], [0]]\nw = [0.0 for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), k) in zip(edge_list, cost_list)\n    w[i, j, :] = k\nend\n\n# origin forward resource and backward forward resource set to 0\nresource = Resource(0.0, 0.0)\n\n# forward and backward expansion functions are equal\nIf = [src(e) for e in edges(graph)]\nJf = [dst(e) for e in edges(graph)]\nff = [ForwardExpansionFunction(d[i, j], w[i, j]) for (i, j) in zip(If, Jf)]\nfb = [BackwardExpansionFunction(d[i, j], w[i, j]) for (i, j) in zip(If, Jf)]\nFF = sparse(If, Jf, ff);\nFB = sparse(If, Jf, fb);\n\ninstance = CSPInstance(graph, 1, nb_vertices, resource, resource, Cost(), FF, FB)\n(; p_star, c_star) = generalized_constrained_shortest_path(instance; W=W)\n@info \"Result\" c_star p_star","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"","category":"page"},{"location":"custom/","page":"Implement a custom problem","title":"Implement a custom problem","text":"This page was generated using Literate.jl.","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"EditURL = \"literate/resource_shortest_path.jl\"","category":"page"},{"location":"resource_shortest_path/#Shortest-path-with-linear-resource-constraints","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"","category":"section"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"In this tutorial we want to solve the following resource constrained shortest path:","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"beginaligned\nmin_pin mathcalP_od  sum_ain p c_a  \nst  sum_ain p w_a^k leq W^k  forall k in K\nendaligned","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"using ConstrainedShortestPaths\nusing Graphs, SparseArrays","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"using GLMakie, GraphMakie","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"Let's create a simple graph:","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"nb_vertices = 4\ngraph = SimpleDiGraph(nb_vertices)\nedge_list = [(1, 2), (1, 3), (2, 3), (2, 4), (3, 4)]\ndistance_list = [1, 2, -1, 1, 1]\nfor (i, j) in edge_list\n    add_edge!(graph, i, j)\nend\nI = [src(e) for e in edges(graph)]\nJ = [dst(e) for e in edges(graph)]\nd = sparse(I, J, distance_list)","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"We now add resource costs w_a on edges, and a resource constraint of the form: sumlimits_ain P w_a leq W","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"W = [1.0]\ncost_list = [[0], [0], [10], [0], [0]]\nw = [0.0 for i in 1:nb_vertices, j in 1:nb_vertices, k in 1:1]\nfor ((i, j), c) in zip(edge_list, cost_list)\n    w[i, j, :] = c\nend","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"graphplot(     graph;     nodecolor=:red,     nlabels=[\"i\" for i in 1:nbvertices],     elabels=[\"d=(desrc edst) w=(w[e.src, e.dst, :])\" for e in edges(graph)], )","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"With these costs, the optimal path should be [1, 2, 4], with length 2.","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"p_star, c_star = resource_shortest_path(graph, 1, nb_vertices, W, d, w)\n@info \"Solution found\" p_star c_star","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"","category":"page"},{"location":"resource_shortest_path/","page":"Shortest path with linear resource constraints","title":"Shortest path with linear resource constraints","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = ConstrainedShortestPaths","category":"page"},{"location":"#ConstrainedShortestPaths.jl","page":"Home","title":"ConstrainedShortestPaths.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for ConstrainedShortestPaths.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package implements algorithms for solving Generalized Constrained Shortest Paths problems. It implements a simplified version of the framework from Parmentier 2017, restricted to acyclic directed graphs.","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you have any question/suggestion, feel free to create an issue or contact me.","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package supports the following setting:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Let D=(V A) an acyclic directed graph.\nLet o din V origin and destination vertices.\nLet mathcalP subset mathcalP_od a subset of o-d paths in D.\nLet c a cost function you want to minimize on mathcalP.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The generalized_constrained_shortest_path algorithm is able to solve the following shortest path problem:","category":"page"},{"location":"","page":"Home","title":"Home","text":"beginaligned\nargminquad  c(P)\ntextstquad  Pin mathcalP\nendaligned","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To install this package, open a julia REPL and run the following command in pkg mode:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add ConstrainedShortestPaths","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Basic-usage","page":"Home","title":"Basic usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Currently, this package implements three applications examples ready to use:","category":"page"},{"location":"","page":"Home","title":"Home","text":"The Usual shortest path problem (basic_shortest_path).\nThe Shortest path with linear resource constraints resource constraints (resource_shortest_path).\nThe Stochastic Vehicle Scheduling subproblem for the column generation formulation (stochastic_routing_shortest_path).","category":"page"},{"location":"#Advanced-usage","page":"Home","title":"Advanced usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If your shortest path problem is not one of those listed in the Basic usage section, it is still possible to solve it with this package. To do this, first read the Mathematical background section, then follow the Implement a custom problem tutorial.","category":"page"},{"location":"utils/","page":"-","title":"-","text":"EditURL = \"utils.jl\"","category":"page"},{"location":"utils/","page":"-","title":"-","text":"using Graphs, SparseArrays\n\nfunction random_acyclic_digraph(nb_vertices::Integer; p=0.4)\n    edge_list = []\n    for u in 1:nb_vertices\n        if u < nb_vertices\n            push!(edge_list, (u, u + 1))\n        end\n\n        for v in (u + 2):nb_vertices\n            if rand() <= p\n                push!(edge_list, (u, v))\n            end\n        end\n    end\n    return SimpleDiGraph(Edge.(edge_list))\nend","category":"page"},{"location":"utils/","page":"-","title":"-","text":"","category":"page"},{"location":"utils/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"}]
}
